# 总结

#### Mysql 索引的底层实现原理，为什么用 B+ 树？什么是 B+ 树？

索引可以理解为一本书的目录，通过缩小查询范围来筛选出最终需要的数据。

在数据库中索引分很多种类，Mysql 最常用的索引底层实现就是 B+ 数，那么为什么使用 B+ 数，而不选择其他数据结构呢？

##### 为什么不是 B 树？

B 树每个节点不仅存储键值，也会存储数据，数据量大的时候，会导致 B 树很深，从而增加磁盘 IO 的次数，影响查询效率。

##### 为什么是 B+ 树？

- 在 B+ 树中，所有数据记录节点都是按照键值的大小存放在同一层的叶子节点上，而非叶子结点只存储key的信息，这样可以大大减少每个节点的存储的key的数量，降低B+ 树的高度
- B+ 树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。
- B+ 树的层级更少：相较于 B 树 B+ 每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快
- B+ 树查询速度更稳定：B+ 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;
- B+ 树天然具备排序功能：B+ 树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
- B+ 树全节点遍历更快：B+ 树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

##### 什么是 B+ 树？

特征：

1. 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
2. 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
3. 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

优势：

1. 单一节点存储更多的元素，使得查询的IO次数更少。
2. 所有查询都要查找到叶子节点，查询性能稳定。
3. 所有叶子节点形成有序链表，便于范围查询。

参考：https://zhuanlan.zhihu.com/p/54102723

#### Redis 消息中间件



#### Redis 雪崩、击穿、穿透

##### 雪崩

同一时间，缓存大批量失效，然后所有请求都打到 DB 数据库，导致 DB 数据库直接崩了。

比如，某一个时间点，刚好缓存批量失效，同时又有活动，大量用户进行请求，就会出现这种情况

**解决方案：**

批量往 redis 存数据的时候，把每个 key 的失效时间加上个随机数，比如 1-5 分钟随机，这样的话就能保证数据不会在同一个时间大面积失效。

##### 击穿

缓存击穿和雪崩类似，雪崩是缓存批量失效，而击穿是某个 key 在一个时间点是热点，不断的被并发请求，而在这期间，该 key 刚好过期，就会出现所有请求都打到 DB 上

**解决方案：**

- 把这个热点 Key 设置为永久有效
- 使用互斥锁

##### 穿透

用户查询缓存和数据库中都没有的数据。

正常的使用缓存流程大致是，数据查询先进行缓存查询，如果 key 不存在或者 key 已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存。

如果用户故意穿一个不存在的参数，如查询用户传 id 为 -1，这时候缓存相当于每起到作用，会全部直接查询 DB 数据库。

**解放方案：**

- 接口层增加严格的参数校验，不合法的直接返回。
- 在缓存查不到，DB 中也没有的情况，可以将对应的 key 的 value 写为 null，或者其他特殊值写入缓存，同时将过期失效时间设置短一点，以免影响正常情况。这样是可以防止反复用同一个 ID 来暴力攻击。
- 正常用户是不会这样暴力功击，只有是恶意者才会这样做，可以在网关 NG 作一个配置项，为每一个 IP 设置访问阈值。
- 高级用户布隆过滤器（Bloom Filter), 这个也能很好地防止缓存穿透。原理就是利用高效的数据结构和算法快速判断出你这个 Key 是否在 DB 中存在，不存在你 return 就好了，存在你就去查了 DB 刷新 KV 再 return。

#### Redis 数据类型

- String: 字符串
- Hash: 哈希
- List: 列表
- Set: 集合
- Sorted Set: 有序集合

#### SQL 注入

