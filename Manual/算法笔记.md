## 数据结构+算法



### 复杂度

#### 时间复杂度

从 CPU 的角度来看，以下示例代码的每一行都执行着类似的操作：**读数据**-**运算**-**写数据**。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里可以粗略估计，可以假设每行代码执行的时间都一样，为 `unit_time`。在这个假设的基础之上，我们来计算每段代码的总执行时间。

##### 示例

**例1：**

```
int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n*unit_time 的执行时间，所以这段代码总的执行时间就是 `(2n+2)*unit_time`。可以看出来，**所有代码的执行时间 T(n) 与每行代码的执行次数成正比**。

**例2：**

```
 int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
```

第 2、3、4 行代码，每行都需要 1 个 unit_time 的执行时间，第 5、6 行代码循环执行了 n 遍，需要 2n * unit_time 的执行时间，第 7、8 行代码循环执行了 n^2遍，所以需要 2n^2 * unit_time 的执行时间。所以，整段代码总的执行时间` T(n) = (2n2+2n+3)*unit_time`

##### 总结

> 所有代码的执行时间 T(n) 与每行代码的执行次数成正比

$$
T(n)=O(f(n))
$$

T(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比

第一个例子中的 T(n) = O(2n+2)，第二个例子中的 T(n) = O(2n2+2n+3)。这就是**大 O 时间复杂度表示法**。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，所以，也叫作**渐进时间复杂度**（asymptotic time complexity），简称**时间复杂度**

当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n^2)

##### 常用时间复杂度

- 常量：O(1)
- 平方：O(n^2)
- 立方：O(n^3)
- K次方阶：O(n^k)
- 对数阶：O(logn)
- 线性对数阶：O(nlogn)
- 线性：O(n)
- 阶乘：O(n!)
- 增数阶：O(2^n)

**1. O(1)**

所有复杂度是常量的都是O(1)，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)

**2. O(logn)、O(nlogn)**

```
i=1;
while (i <= n)  {
   i = i * 2;
}
```

变量 i 的值从 1 开始取，每循环一次就乘以 2。2^x=n，x=log2n，所以，这段代码的时间复杂度就是 O(log2n)。

```
i=1;
while (i <= n)  {
   i = i * 3;
}
```

改变一下，这段代码的时间复杂度为 O(log3n)

实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。

对数之间是可以互相转换的，log3n 就等于 log32 * log2n，所以 O(log3n) = O(C * log2n)，其中 C=log32 是一个常量。基于我们前面的一个理论：**在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))**。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。

如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。

#### 空间复杂度

空间复杂度全称就是**渐进空间复杂度**（asymptotic space complexity），**表示算法的存储空间与数据规模之间的增长关系**。

```
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }
 
  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。

我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。

### 数组和链表

#### 数组

>  数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
>
> 数组不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构 

 **为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？** 

> 从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址 

####  链表

##### 单链表

>  通过指针将一组零散的内存块串联在一起 ， 把内存块称为链表的“**结点**”。  记录下个结点地址的指针叫作**后继指针 next** ， 一个结点叫作**头结点**，把最后一个结点叫作**尾结点** 。

##### 循环链表

>  **循环链表是一种特殊的单链表**。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点 

 和单链表相比，**循环链表**的优点是从链尾到链头比较方便。 

##### 双向链表

 支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点 

#### 数组和链表的区别

-  链表适合插入、删除，时间复杂度 O(1)； 数组支持随机访问，根据下标随机访问的时间复杂度为 O(1) 
-  数组需要一块**连续的内存空间**来存储 ， 链表通过“指针”将一组**零散的内存块**串联起来使用 

### 栈

>  后进者先出，先进者后出 

 用数组实现的栈，我们叫作**顺序栈**，用链表实现的栈，我们叫作**链式栈** 

当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。

#### 栈的应用

- 表达式求职

- 括号匹配

### 队列

> 先进先出， 队列跟栈一样，也是一种**操作受限的线性表数据结构**。 

 用数组实现的队列叫作**顺序队列**，用链表实现的队列叫作**链式队列** 

### 图谱

#### 知识图谱

![](image/201911202024.png)