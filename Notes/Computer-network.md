# 计算机网络

### 基础

#### OSI七层、TCP/IP五层协议

**OSI** （Open System Interconnect），开放式系统互联，它是一个国际标准化组织制定的一个用于计算机或通信系统间互联的标准体系。

OSI 七层协议是一种国际规范，将网络协议分成了 7 层，分别是：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。

TCP/IP 四层协议是围绕 TCP/IP 展开的一系列通信协议，是参考 OSI 七层协议进行的分层

TCP/IP 五层协议是为了方便学习计算机网络原理而采用的，综合了OSI七层模型和TCP/IP的四层模型而得到的五层模型

OSI七层协议和 TCP/IP 四层、五层协议结构对应关系如下图所示：

![1557064350664](../Image/oldimg/1557064350664.png)

- 应用层
    - 作用：为操作系统或网络应用程序提供访问网络服务的接口
    - 协议：**HTTP、HTTPS、FTP**、POP3、DNS、Telnet、SMTP、WWW、NFS 等
    - 数据单元：APDU
- 表示层
    - 作用：提供格式化的表示和转换数据服务，数据的翻译、加密和压缩
    - 协议：JPEG、MPEG、ASII
    - 数据单元：PPDU
- 会话层
    - 作用：建立、管理和终止会话
    - 协议：NFS、SQL、NETBIOS、RPC
    - 数据单元：SPDU
- 传输层（运输层）
    - 作用：提供端到端的可靠报文传递和错误恢复
    - 协议：**TCP、UDP**、SPX
    - 数据单元：段 Segment
- 网络层（IP协议层）
    - 作用：通过IP寻址建立两个节点之间的连接，为源端的传输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。
    - 协议：**IP**、ICMP、IGMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）
    - 数据单元：数据包 PackeT
- 数据链路层
    - 作用：将比特组合成字节，再将字节组合成帧，使用链路层地址 (以太网使用MAC地址)来访问介质，并进行差错检测。作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等
    - 协议：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）
    - 数据单元：帧 Frame
- 物理层
    - 作用：通过媒介传输比特，确定机械及电气规范
    - 协议：RJ45、CLOCK、IEEE802.3 （网线、中继器，集线器）
    - 数据单元：比特 Bit

#### TCP/UDP

TCP和UDP是传输层的两个传输协议

TCP 的全称叫传输控制协议（Transmission Control Protocol），大部分应用使用的都是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。

UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过难度比较高。

应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 **TCP 段**（*TCP Segment*）。

当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是**端口**。

#### 在浏览器中输入一个URL地址，都发生了什么？

**HTTP解析**

首先，浏览器会对URL进行解析，生成要发生给web服务器的HTTP数据包

**DNS解析**

生成数据包后，需要委托系统将HTTP数据包发送出去，但是发生前需要知道发生给谁，也就是需要根据域名解析到IP地址信息。

DNS解析过程简述：

- 浏览器会先查看缓存是否存在，不存在则下一步操作系统会看自己的缓存，如果还是不存在，会查询host文件中是否存在，不存在则进行下一步
- 客户端发送域名信息给本地DNS服务器
- 本地DNS服务器先在缓存中查找，如果缓存中存在，则直接返回对应IP地址，不存在则请求根域名服务器
- 根域服务器会返回对应顶级域名服务器查询地址
- 本地DNS服务器再请求顶级域名服务器查询地址，顶级域名服务器返回权威DNS服务器查询地址
- 本地DNS服务器再请求权威DNS服务器，权威DNS服务器返回了具体的IP地址
- 本地DNS服务器得到IP地址后返回给客户端

**协议栈**

通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的**协议栈**

协议栈中提供接下来的工作步骤

**TCP传输**

通过TCP的三次握手建立TCP连接，生成TCP报文

**IP远程定位**

生成TCP数据包后，需要通过网络层的IP将数据封装成网络包进行发送

此阶段会生成IP报文

**MAC传输**

生成IP报文后，接下来网络包还需要在 IP 头部的前面加上 **MAC 头部**

**网卡出口**

将网络包的数字信息转化成电信号，使其能够在网线上传输

**出口交换机**

电信号到达网线接口后，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号

交换机通过包末尾的 `FCS` 校验错误，如果没问题则放到缓冲区，

然后交换机根据 MAC 地址表查找 MAC 地址对应端口，然后将信号发送到相应的端口（达到路由器）

**发送方路由器**

网络包经过交换机之后，到达发送方路由器，并在此被转发到下一个路由器或目标设备

首先路由器端口会接收发给自己的以太网包，然后路由表查询转发目标，再由相应的端口作为发送方将以太网包发送出去

**转发路由器**

接收包：

- 电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 `FCS` 进行错误校验；
- 如果没问题则检查 MAC 头部中的**接收方 MAC 地址**，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。

查询路由表确定输出端口：

- 接下来路由器会丢弃掉MAC头部，然后根据 MAC 头部后方的 `IP` 头部中的内容进行包的转发操作

发送包：

- 根据路由表的网关列判断对方的IP地址
- 通过 `ARP` 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址
- 生成网络包，转化成点信号发送出去

**转发交换机**

发送出去的网络包会通过**交换机**到达下一个路由器

**目标路由器**

目标主机的路由器，发现 IP 地址是自己局域网内的主机，就会通过 ARP 请求获取目标主机的 MAC 地址，从而转发到这个服务器主机

**服务器**

数据包达到服务器后，服务器就会开始接收验证

- 首先验证 MAC 地址是否是自身的 MAC 地址
- 查看IP地址是否符合
- 查看IP报文中的协议，如果是TCP协议
- 继续查看TCP中序列号是否是自己想要的，如果是则存入缓存然后返回一个ACK确认信号
- TCP报文中存在端口号，HTTP服务监听着这个端口，服务器将这个包发送给对应的HTTP服务进程
- HTTP服务器根据接收到的数据包，将响应数据包发送给客户端

数据包发送后也经过网卡、交换机、路由、交换机，最后到达客户端，客户端解析数据包进行处理

最后，客户端向服务端发起四次挥手进行断开连接操作

#### MTU和MSS

- `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节；
- `MSS`：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；

### TCP

#### TCP和UDP的区别

1.连接

- TCP 是面向连接的传输层协议，传输数据前先要建立连接。
- UDP 是不需要连接，即刻传输数据。

2.服务对象

- TCP 是一对一的两点服务，即一条连接只有两个端点。
- UDP 支持一对一、一对多、多对多的交互通信

3.可靠性

- TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。
- UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议

4.拥塞控制、流量控制

- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
- UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

5.首部开销

- TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 `20` 个字节，如果使用了「选项」字段则会变长的。
- UDP 首部只有 8 个字节，并且是固定不变的，开销较小。

6.传输方式

- TCP 是流式传输，没有边界，但保证顺序和可靠。
- UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

7.分片不同

- TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
- UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。

#### TCP和UDP应用场景

由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

- `FTP` 文件传输；
- HTTP / HTTPS；

由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如 `DNS` 、`SNMP` 等；
- 视频、音频等多媒体通信；
- 广播通信；

#### TCP和UDP对应的应用层协议？

TCP：

- HTTP1.0、HTTP1.1、HTTP2
- HTTPS
- FTP：文件传输协议
- SMTP：邮件传输协议
- POP3：邮局协议
- SSH：远程登录
- TELNET：网络电传
- ...

UDP：

- HTTP3
- DNS：域名服务
- TFTP：简单文件传输协议
- RTP：实时传输协议

#### TCP 的三次握手和四次挥手

##### 什么是三次握手、四次挥手？

TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 ip 地址、端口号等。

TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。

TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用四次挥手来关闭一个连接。

- ACK：确认、使得确认信号有效
- SYN：用于初始化连接的序列号
- FIN：该报文的发送方已经结束向对方发送数据

##### 三次握手

- 第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；
- 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
- 第三次握手：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

握手过程中传送的**包里不包含数据**，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

##### 四次挥手

与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。

- 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。
- 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。
- 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
- 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

**总结：**

> **三次握手：**客户端发送请求等待服务器端确认；服务器端收到请求同时发送请求给客户端，等待客户端回应；客户端收到服务器端的请求，向服务器端发送确认包，发送完毕，客户端和服务器端进入ESTABLISHED状态

##### 为什么会采用三次握手，若采用二次握手可以吗？

- 三次握手才可以阻止重复历史连接的初始化（主要原因）
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费

TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。

采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。
采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况。

总结：

- 第一次握手，服务端可知客户端的发送能力、服务端的接受能力OK
- 第二次握手，客户端可知服务端和客户端的发送能力、接受能力都OK
- 第三次握手，服务端可知服务端和客户端的发送能力、接受能力都OK

##### 为什么需要四次挥手？

TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。

当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。

但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。

因此，另一个方向也需要用同样的方式关闭连接。

##### TCP 四次挥手可以变成三次吗？

**为什么需要四次挥手？**

服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序：

- 如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数；
- 如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数，

从上面过程可知，是否要发送第三次挥手的控制权不在内核，而是在被动关闭方（上图的服务端）的应用程序，因为应用程序可能还有数据要发送，由应用程序决定什么时候调用关闭连接的函数，当调用了关闭连接的函数，内核就会发送 FIN 报文了，所以服务端的 ACK 和 FIN 一般都会分开发送。

**什么情况下会出现三次挥手？**

当被动关闭方（上图的服务端）在 TCP 挥手过程中，**「没有数据要发送」并且「开启了 TCP 延迟确认机制」**，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。

**什么是 TCP 延迟确认机制？**

- 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
- 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK

### HTTP

HTTP（HyperText Transfer Protocol） ：超文本传输协议。

HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」

#### HTTP常见的状态码

`1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少；

- **「101」**表示将切换协议，常见于WebSocket连接

`2xx` 类状态码表示服务器**成功**处理了客户端的请求：

- 「**200 OK**」成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。
- 「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

`3xx` 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**：

- 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- 「**302 Found**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。
    - 301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。

`4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理：

- 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误；
- 「**401 Unauthorized**」客户端没有权限访问；
- 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错；
- 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端；
- **「405 Method Not Found」**客户端请求方法不被允许；

`5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码：

- 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- 「**501 Not Implemented**」表示客户端请求的功能还不支持。
- 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。

#### HTTP和HTTPS的区别

- HTTP：超文本传输协议、明文、80端口、不安全、URL以`http:// 开头`
- HTTPS：ca证书、ssl加密传输、443端口、安全、HTTPS连接缓存不如HTTP高效、URL以`https:// 开头`

#### HTTP的基本优化

带宽、延迟（浏览器阻塞、DNS查询、建立连接）

#### HTTP1.0和HTTP1.1的区别

缓存处理、带宽优化及网络连接的使用、错误通知的管理、host头处理、长连接

#### HTTP2

- 兼容 HTTP1.1
- 头部压缩
- HTTP/2 厉害的地方在于将 HTTP/1 的文本格式改成二进制格式传输数据，极大提高了 HTTP 传输效率，而且二进制数据使用位运算能高效解析
-  HTTP/2 通过 Stream 这个设计，多个 Stream 复用一条 TCP 连接，达到并发的效果，解决了 HTTP/1.1 队头阻塞的问题，提高了 HTTP 传输的吞吐量

#### HTTP1.1的优化

降低延迟、请求优先级、header压缩、基于https的加密协议传输、服务器推送

#### HTTP2.0和HTTP1.1相比

新的二进制格式、多路复用、header压缩、服务器推送

#### HTTP请求方法有哪些？

- GET：向特点资源获取请求
- POST：向指定资源提交数据进行处理请求
- HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回
- PUT：向指定资源位置上传其最新内容
- DELETE：请求服务器删除 Request-URI 所标识的资源
- TRACE：回显服务器收到的请求，主要用于测试或诊断
- OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法

#### GET和POST的区别

安全和幂等的定义：

- 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
- 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

根据 RFC 规范定义的语义来分析：

- GET 是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。
- POST 是根据请求对指定资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。

但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：

- 可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等；
- 可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。

**GET 请求可以带 body 吗？**

可以，任何请求都可以携带 body，只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。

另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。



总结下一些差异点：

- GET参数通过URL传递，POST放在Request body中。
- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST没有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET产生一个TCP数据包；POST产生两个TCP数据包。

#### XSS（跨站脚本）攻击

发生在目标用户的浏览器层面上的，当渲染DOM树的过程成发生了不在预期内执行的JS代码时，就发生了XSS攻击。大多数XSS攻击的主要方式是嵌入一段远程或者第三方域上的JS代码

- 一旦在DOM解析过程成出现不在预期内的改变（JS代码执行或样式大量变化时），就可能发生XSS攻击
- XSS分为反射型XSS，存储型XSS和DOM XSS
- 反射型XSS是在将XSS代码放在URL中，将参数提交到服务器。服务器解析后响应，在响应结果中存在XSS代码，最终通过浏览器解析执行。
- 存储型XSS是将XSS代码存储到服务端（数据库、内存、文件系统等），在下次请求同一个页面时就不需要带上XSS代码了，而是从服务器读取。
- DOM XSS的发生主要是在JS中使用eval造成的，所以应当避免使用eval语句。
- XSS危害有盗取用户cookie，通过JS或CSS改变样式，DDos造成正常用户无法得到服务器响应。
- XSS代码的预防主要通过对数据解码，再过滤掉危险标签、属性和事件等。

#### RPC和HTTP的区别

RPC和HTTP协议都是基于TCP协议

TCP 是有三个特点，**面向连接**、**可靠**、基于**字节流**

由于是基于字节流，所以传输的01串没有边界，无法进行断句，

因此，需要在此基础上加上一些规则，用于区别消息边界，

把发送的消息进行包装，变成 消息头+消息体 格式，消息头里会存放一些约定信息，这样就形成了新的协议

如：RPC和HTTP就是基础TCP协议延伸出来的

- HTTP协议为超文本传输协议，RPC是远程过程调用协议
- RPC 本质上不算是协议，而是一种调用方式，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议
- 一般对外使用HTTP服务，内部微服务直接使用RPC服务
- **服务发现方式**：HTTP需要通过DNS服务获取IP和端口进行连接，RPC通过专门的服务保存IP和端口信息
- **底层连接形式**：HTTP 默认在建立底层 TCP 连接之后会一直保持这个连接，之后的请求和响应都会复用这条连接；而RPC也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用
- **传输内容**：HTTP1.1 传输内容字符串格式，通过json序列化结构体；RPC 使用Protobuf 或其他序列化协议去保存结构体数据（二进制），体积更小，同时不需要考虑各种浏览器情况，性能更好

#### 常见的RPC框架

- **gRPC**：是一种高性能的远程过程调用框架，使用 Protocol Buffers 作为默认的序列化协议，支持**多语言**和平台。gRPC 提供了高效的序列化和传输协议，以及代码生成和服务发现等功能，可以大大提高 RPC 接口的开发效率和性能。
- **Thrift**：最初是由 Facebook 开发的内部系统跨语言的 RPC 框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一，支持**多语言**。
- **Dubbo**：是一种基于 **Java** 的高性能 RPC 框架，支持多种序列化协议和负载均衡算法。Dubbo 提供了完整的服务治理方案，包括服务注册、服务发现、负载均衡、容错处理等。
- **Spring Cloud**：国外 Pivotal 公司 2014 年对外开源的 RPC 框架，仅支持 **Java** 语言。
- **Tars**：是一种基于 **C++** 的高性能 RPC 框架，支持多种序列化协议和负载均衡算法。Tars 提供了完整的服务治理方案，包括服务注册、服务发现、负载均衡、容错处理等，同时还提供了可视化的管理界面，方便运维人员进行管理和监控。
- **Motan**：微博内部使用的 RPC 框架，于 2016 年对外开源，仅支持 **Java** 语言。

#### Websocket和HTTP的区别

TCP 连接的两端，同一时间里，双方都可以主动向对方发送数据，这就是**全双工**。

而`HTTP/1.1`，也是基于TCP协议的，同一时间里，客户端和服务器只能有一方主动发数据，这就是半双工。

因为 HTTP1.1 设计之初没有考虑到游戏这种需要频繁的进行互相发送消息的场景。

Websocket也是基于TCP的协议，支持双向通信。

