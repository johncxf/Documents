# 操作系统

## 进程管理

### 进程与线程

#### 进程

我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个运行中的程序，就被称为「进程」（Process）。

**进程是操作系统进行资源分配的基本单位**。并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。

##### 进程状态

在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、阻塞状态。

- 运行状态（*Running*）：该时刻进程占用 CPU；
- 就绪状态（*Ready*）：可运行，由于其他进程处于运行状态而暂时停止运行；
- 阻塞状态（*Blocked*）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；

进程还有另外两个基本状态：

- 创建状态（*new*）：进程正在被创建时的状态；
- 结束状态（*Exit*）：进程正在从系统中消失时的状态；

在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。那么，就需要一个新的状态，来描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态：

- 阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；
- 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；

导致进程挂起的原因不只是因为进程所使用的内存空间不在物理内存，还包括如下情况：

- 通过 sleep 让进程间歇性挂起，其工作原理是设置一个定时器，到期后唤醒进程。
- 用户希望挂起一个程序的执行，比如在 Linux 中用 `Ctrl+Z` 挂起进程；

##### 进程的控制结构

在操作系统中，是用进程控制块，简称 PCB（*process control block*）数据结构来描述进程的。

PCB 是进程存在的唯一标识，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。

##### 进程的上下文切换

各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行，那么一个进程切换到另一个进程运行，称为进程的上下文切换。

什么场景需要进行进程的上下文切换：

- 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；
- 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；
- 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；
- 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；
- 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；

#### 线程

调度的基本单位。进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位，线程也被称为轻量级进程。

为什么会有线程：请求多的时候如果为每一个请求创建一个进程，系统开销大响应用户请求效率低，因此引入线程

- 线程的执行过程是线性的，进程所拥有的资源只为改线状执行过程服务，一旦发生线程切换，这些资源需要被保护起来
- 线程分为单线程和多线程

##### 线程的实现

- 用户线程（User Thread）：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；
- 内核线程（Kernel Thread）：在内核中实现的线程，是由内核管理的线程；
- 轻量级进程（LightWeight Process）：在内核中来支持用户线程；

#### 协程

协程（Coroutine）本质上是一种用户态线程，你可以把它看作轻量级的线程，不需要操作系统来进行抢占式调度，系统开销极小，可以有效提高线程的任务并发性，避免多线程的缺点。

#### 进程和线程的区别

- 进程是资源（包括内存、打开的文件等）分配的单位，线程是处理器调度的基本单位
- 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间
- 资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、CPU，但是进程之间的资源是相互独立的
  - 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮
  
  - 进程切换时，消耗的资源大，效率高
  
- 执行过程：每个独立的进程有一个程序运行的入口，顺序执行序列。但是线程不能独立运行
- 线程能减少并发执行的时间和空间开销；
    - 线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
    - 线程的终止时间比进程快，因为线程释放的资源相比进程少很多；
    - 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
    - 由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；


#### 调度

操作系统切换进程的运行状态称为程序的调度。

### 进程间通信方式

每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。

#### 管道

```sh
ps -ef | grep mysql
```

以上命令中 `|`就是管道，将前一个命令的输出作为后一个命令的输入，以上会开启2个子进程。

可以看出管道传输数据是单向的，如果想相互通信，我们需要创建两个管道才行。

管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。

#### 消息队列

A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。

#### 共享内存

共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。

#### 信号量

信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。

信号量表示资源的数量，控制信号量的方式有两种原子操作：

- 一个是 **P 操作**，这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。
- 另一个是 **V 操作**，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；

#### 信号

对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。

在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 `kill -l` 命令，查看所有的信号。

运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如

- Ctrl+C 产生 `SIGINT` 信号，表示终止该进程；
- Ctrl+Z 产生 `SIGTSTP` 信号，表示停止该进程，但还未结束；

如果进程在后台运行，可以通过 `kill` 命令的方式给进程发送信号：

- `kill -9 1050` ，表示给 PID 为 1050 的进程发送 `SIGKILL` 信号，用来立即结束该进程；

所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。

信号是进程间通信机制中**唯一的异步通信机制**，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。

- 执行默认操作：Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。
- 捕捉信号：我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。
- 忽略信号：当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SEGSTOP`，它们用于在任何时候中断或结束某一进程。

#### socket

前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想**跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。**

### 死锁

两个或者以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，他们将无法推进下去。此时称系统处于死锁状态或者系统产生了死锁，这些永远相互等待的进程称为死锁

#### 产生原因

- 系统资源的竞争
- 进程运行推进顺序不合适

#### 四个必要条件

同时满足以下四个条件才会产生死锁：

- 互斥条件：多个进程（线程）不能同时使用同一个资源
- 请求与保持条件：线程A已占有资源1，又想使用资源2，而资源2被线程B占用，所以线程A只能等待，但是等待的时候又不会释放资源1
- 不可剥夺条件：当一个线程自己占有资源后，在用完释放前，其他线程无法使用
- 循环等待条件：线程A已占有资源1，又想使用资源2，线程B占用资源2，想申请资源1，两个线程陷入了循环等待中

#### 死锁避免

死锁产生需要四个必要添加，所以避免死锁产生只需要破坏互斥、请求与保持、不可剥夺、循环等待4个中的一个条件就无法产生死锁。

一般避免死锁最常见的就是资源的有效分配：

系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略

如果操作系统能保证所有进程在有限时间内得到需要的全部资源，则系统处于安全状态否则系统是不安全的

#### 死锁预防

- 破坏“不可剥夺”条件
- 破坏“请求与保持条件”
- 破坏“循环等待”条件

### 多线程冲突

这里用go协程来演示：

```go
package main

import (
	"fmt"
	"time"
)

var num = 0

func add() {
	for i := 0; i < 10000; i++ {
		num++
	}
}

func main() {
	go add()
	go add()
	time.Sleep(3 * time.Second)
	fmt.Printf("num: %d", num)
}
```

输出：

```
num: 15354%
```

每次输出结果不同，很少出现能等于20000的情况

这里就是冲突导致

这里先了解几个概念：

- **临界区**：由于多线程执行操作共享变量的这段代码可能会导致竞争状态，因此我们将此段代码称为临界区（critical section），它是访问共享资源的代码片段，一定不能给多线程同时执行；
- **互斥**：保证一个线程在临界区执行时，其他线程应该被阻止进入临界区，也就是同时只能执行一个线程；
- **同步**：并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步；

#### 互斥和同步的实现

为了实现进程/线程间正确的协作，操作系统必须提供实现进程协作的措施和方法，主要的方法有两种：

- *锁*：加锁、解锁操作；
- *信号量*：P、V 操作；

##### 锁

使用加锁操作和解锁操作可以解决并发线程/进程的互斥问题。

任何想进入临界区的线程，必须先执行加锁操作。若加锁操作顺利通过，则线程可进入临界区；在完成对临界资源的访问后再执行解锁操作，以释放该临界资源。

##### 信号量

信号量是操作系统提供的一种协调共享资源访问的方法。

通常**信号量表示资源的数量**，对应的变量是一个整型（`sem`）变量。

另外，还有**两个原子操作的系统调用函数来控制信号量的**，分别是：

- *P 操作*：将 `sem` 减 `1`，相减后，如果 `sem < 0`，则进程/线程进入阻塞等待，否则继续，表明 P 操作可能会阻塞；
- *V 操作*：将 `sem` 加 `1`，相加后，如果 `sem <= 0`，唤醒一个等待中的进程/线程，表明 V 操作不会阻塞；

### 悲观锁、乐观锁

#### 互斥锁与自旋锁

互斥锁和自旋锁是最基础的两种锁，其他很多锁基于这两种锁进行实现。

当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式：

- **互斥锁**加锁失败后，线程会**释放 CPU** ，给其他线程；
- **自旋锁**加锁失败后，线程会**忙等待**，直到它拿到锁；

#### 读写锁

读写锁由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。

> 读写锁适用于能明确区分读操作和写操作的场景，在读多写少的场景，能发挥出优势。

读写锁的工作原理：

- 当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。
- 但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。

#### 乐观锁和悲观锁

互斥锁、自旋锁、读写锁，都是属于悲观锁。

悲观锁认为**多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁**。

乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：**先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作**。

文档多人在线编辑、git提交等都是使用乐观锁，只有提交冲突的时候才会提示。

乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以**只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。**
